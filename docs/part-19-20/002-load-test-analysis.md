## 결과 데이터

- 케이스 1
  - 20 rps(5s) → 40 rps(5s) → 80 rps(5s) → 160 rps(5s) → 320 rps(5s) → 160 rps(5s)
  - ```
    █ THRESHOLDS

      http_req_duration
      ✗ 'p(95)<800' p(95)=23.22s

      http_req_failed
      ✗ 'rate<0.02' rate=36.44%

      order_success
      ✓ 'rate>0.98' rate=100.00%


    █ TOTAL RESULTS

      checks_total.......................: 3427   66.956413/s
      checks_succeeded...................: 63.55% 2178 out of 3427
      checks_failed......................: 36.44% 1249 out of 3427

      ✗ register 201
        ↳  36% — ✓ 726 / ✗ 1249
      ✓ charge 200/201
      ✓ order 200/201
    ```

- 케이스 2
  - 5 rps(10s) → 10 rps(10s) → 15 rps(10s) → 20 rps(5s)
  - ```
    █ THRESHOLDS

      http_req_duration
      ✗ 'p(95)<800' p(95)=1.59s

      http_req_failed
      ✓ 'rate<0.02' rate=0.00%

      order_success
      ✓ 'rate>0.98' rate=100.00%


    █ TOTAL RESULTS

      checks_total.......................: 936     25.756154/s
      checks_succeeded...................: 100.00% 936 out of 936
      checks_failed......................: 0.00%   0 out of 936

      ✓ register 201
      ✓ charge 200/201
      ✓ order 200/201
    ```

- ## 케이스 3
  - 6 rps(10s) → 8 rps(10s) → 10 rps(10s) → 12 rps(10s) → 14 rps(10s)
  - ```
    █ THRESHOLDS

      http_req_duration
      ✓ 'p(95)<800' p(95)=82.84ms

      http_req_failed
      ✓ 'rate<0.02' rate=0.00%

      order_success
      ✓ 'rate>0.98' rate=100.00%


    █ TOTAL RESULTS

    checks_total.......................: 1287 25.604375/s
    checks_succeeded...................: 100.00% 1287 out of 1287
    checks_failed......................: 0.00% 0 out of 1287

    ✓ register 201
    ✓ charge 200/201
    ✓ order 200/201
    ```

## 결과 데이터 분석

- 요약
  - **케이스 1**: 급격한 램핑(최대 320 rps 구간)에서 `http_req_failed` 36.44%, p95 23.22s로 임계치 초과. 가입 단계에서 대량 실패가 발생해 전체 시나리오가 붕괴.
  - **케이스 2**: 중간 레벨(최대 20 rps)에서는 실패율 0%이나 p95 1.59s로 응답시간 임계치(800ms)를 넘음.
  - **케이스 3**: 6→14 rps 구간에서 실패 0%, p95 82.84ms로 모든 임계치 통과. 본 환경에서의 안정 구간.

- 해석
  - 케이스 1의 대규모 실패는 시나리오 첫 단계인 `회원가입`의 병목이 주도했을 가능성이 큼. 가입 실패로 후속 `충전/주문` 호출이 줄어들어 `order_success` 지표는 왜곡되어 100%로 보일 수 있음(성공적으로 주문까지 도달한 트랜잭션만 母수로 집계되기 때문).
  - 케이스 2의 p95 1.59s는 실패는 없지만 전체 시나리오(가입→충전→주문) 비용이 누적된 결과. 단일 엔드포인트 기준의 성능 한계로 보기엔 편향 가능성이 큼.
  - 케이스 3은 동일한 E2E 시나리오에서 14 rps까지 안정적이므로, “가입/충전/주문을 모두 포함한” 종단 간 처리량의 현재 지속 가능 상한을 약 12~14 rps 수준으로 추정 가능.

- 병목 가설
  - **회원가입(암호 해시)**: bcrypt/argon2 등의 해시 비용으로 CPU가 포화되면 응답 대기열이 길어지고 타 단계까지 영향.
  - **지나치게 복합한 시나리오**: 한 시나리오에 3개의 쓰기성 API(가입, 충전, 주문)가 모두 포함되어 동일 시각에 서로 다른 리소스를 쟁탈. 단일 주문 경로 성능을 보기엔 노이즈가 큼.
  - **DB 잠금/경합**: 충전/주문 단계의 포인트/재고 업데이트에서 테이블/행 잠금 경합 가능성. => 충전은 유저마다라 경합 없는데, 재고가 경합 + 락 제일 심함.

- 지속 가능한 처리량(가설)
  - E2E(가입→충전→주문) 기준: 현재 환경에서 약 14~16 rps. (여기서의 1 request = 가입+충전+주문)
  - 주문 엔드포인트 단독 기준: 별도 실험 필요(가입/충전 제거 시 더 높은 RPS 기대).

- 가능한 후속 실험
  1. **주문 전용 부하**: 사전 가입·충전된 사용자 토큰을 재사용하여 `POST /api/orders`만 타깃팅. 현재 p95 임계(800ms) 하에서 지속 가능한 최대 RPS 재탐색.
  2. **가입 전용, 충전 전용 분리 테스트**: 병목 단계(해시/트랜잭션)를 분리 계측해 각 단계의 한계치와 튜닝 포인트 식별.
  3. **부하 모델 정교화**: 케이스 3의 12→14 rps 인근에서 `constant-arrival-rate`로 장시간(5~10분) 안정성 확인 및 GC/풀 고갈 여부 관찰.
  4. **스크립트 정비**: 고빈도 구간에서의 `console.log` 제거, 반복 불필요한 JSON 파싱 최소화 등 부하 생성기 오버헤드 축소.
  5. **관측/프로파일링**: DB 슬로우쿼리, 락 대기 시간, 커넥션 풀 사용률, 애플리케이션 CPU/이벤트루프 지연을 함께 수집.

- 현재 상황에서 개선해볼 수 있는 부분
  - 가입 해시 비용 완화(워크 팩터 조정, 비즈니스 상황 허용 시 비동기 처리/큐잉) 또는 사전 가입 데이터 사용으로 주문 경로 측정의 순도를 높임.
  - 재고 쪽 인덱스/트랜잭션/락 경합 상황을 조금 더 자세히 보고 최적화 해 볼 수 있음.

## 멘토링에서 받은 조언

### 1. 커넥션 풀

- 커넥션 풀 현재 typeorm default 10개인데 다른 수치로 조정해보기

### 2. 프로파일링

- 어떤 코드가 어떻게 병목인지 보려면 코드 프로파일링 기능을 쓰면됨.
- 실제로 써봤더니 예전에 프론트엔드 튜닝할 때 쓰던 Chrome Dev Tools의 Performance 탭을 Node.js 환경에서 사용할 수 있었음. 대박!!
