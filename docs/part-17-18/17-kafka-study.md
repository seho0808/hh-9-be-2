## 카프카(Kafka) 기본 개념

### 카프카 한 줄 요약

- 대량의 이벤트를 안전하고 빠르게 모아 저장하고 다른 서비스에 전달해주는 분산 로그 시스템.

### 왜 쓰는가

- **확장성**: 파티션으로 자연스러운 수평 확장
- **내결함성**: 복제로 장애에도 데이터 손실 최소화
- **유연성**: 실시간 처리(스트리밍), 이벤트 소싱, 로그 집계 등 폭넓은 활용

### 핵심 개념(필수 5가지)

- **Topic**: 메시지 카테고리(채널)
- **Partition**: 토픽을 쪼갠 정렬된 로그 조각(순서는 파티션 안에서만 보장)
- **Offset**: 파티션 내 메시지 위치(소비자가 어디까지 읽었는지 표시)
- **Broker / Replication / ISR**: 서버가 데이터를 저장하고 복제, ISR은 리더와 동기화된 복제본 집합
- **Consumer Group**: 같은 그룹의 컨슈머들이 파티션을 나눠 병렬 처리(각 파티션은 동시에 한 인스턴스에게만 할당)

### 어떻게 쓰는가

- **Producer**: `key`로 파티션을 선택(같은 키 → 같은 파티션 → 순서 유지). 처리량을 위해 배치/압축을 적절히 사용.
- **Consumer**: 그룹으로 묶어 파티션을 분산 소비. 오프셋 커밋 타이밍이 재처리/중복에 영향.

### 전달 보장과 순서

- **At-most-once**: 유실 가능하지만 중복 없음(커밋이 먼저). 로그/지표 등 유실 허용 시.
- **At-least-once**: 유실 없음, 중복 가능(처리 후 커밋). 일반적인 기본값.
- **Exactly-once(EOS)**: 중복/유실 모두 방지(멱등 프로듀서 + 트랜잭션). 비용과 복잡도 존재.
- 순서는 파티션 내에서만 보장. “키 설계”가 곧 순서 전략.

### 저장 정책 BP

- **Retention**: 오래된 로그를 시간/크기 기준으로 삭제(장기보관용 스토리지가 아님)
- **Log Compaction**: 키당 최신 값만 유지(상태 스냅샷에 유용)

### 호출 예시

CLI 기준

```bash
# 토픽 생성(파티션 3, 복제 3)
kafka-topics.sh --create \
  --topic orders \
  --partitions 3 \
  --replication-factor 3 \
  --bootstrap-server localhost:9092

# 생산(키,값)
kafka-console-producer.sh \
  --topic orders \
  --property parse.key=true \
  --property key.separator="," \
  --bootstrap-server localhost:9092
# 예) user-1,{"event":"OrderCreated","id":123}

# 소비(그룹 지정)
kafka-console-consumer.sh \
  --topic orders \
  --group order-service \
  --from-beginning \
  --bootstrap-server localhost:9092
```

### 초보자가 자주 하는 실수

#### 1. 파티션 키

- **문제**: 파티션 수만 늘리고 키 설계는 소홀히 함
- **결과**: 메시지 순서 깨짐, 재처리 시 혼선 발생
- **해결**: 비즈니스 로직에 맞는 키 전략 수립 필요

#### 2. 오프셋 커밋 전략

- **문제**: 자동 커밋을 켜둔 채 장애 상황을 고려하지 않음
- **결과**: 메시지 중복 처리 또는 유실 발생 시 원인 파악 어려움
- **해결**: 수동 커밋으로 처리 완료 후 명시적 커밋

#### 3. 리밸런스 대응

- **문제**: 컨슈머 리밸런스 시 처리 중이던 레코드에 대한 대비 부족
- **결과**: 동일 메시지의 중복 처리 발생
- **해결**: 멱등성 보장 또는 중복 처리 감지 로직 구현

#### 4. 스키마 관리

- **문제**: 스키마 변경을 즉흥적으로 진행
- **결과**: 기존 컨슈머에서 파싱 오류 발생
- **해결**: 스키마 레지스트리 도입 및 호환성 정책 수립
