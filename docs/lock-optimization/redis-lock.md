## Redis 분산 Lock 최적화 방안

### 서론

- Redlock은 다음과 같은 한계가 있습니다.
  - 여러 Redis 마스터에 대한 정족수 합의로 락을 획득해도, 네트워크 지연/GC/리더 교체 동안 과거 락 보유자가 작업을 이어갈 수 있습니다.
  - 표준 구현에는 펜싱 토큰이 없어 외부 리소스에 대한 쓰기 순서를 강제할 수 없습니다.
- 따라서 정합성이 최우선인 경로에서는 다음 대안을 우선합니다.
  - DB 트랜잭션 락: `SELECT ... FOR UPDATE`(비관적) 또는 버전 컬럼 기반 낙관적 락 + 재시도, 유니크 제약
  - Postgres Advisory Lock: 동일 DB 클러스터 내 키 기반 직렬화
  - ZooKeeper/etcd/Consul 기반 분산락: 세션/임대와 펜싱 토큰 제공
  - 파티셔닝/싱글 컨슈머(큐/스트림)로 키별 직렬화
  - Redis를 사용할 경우, 펜싱 토큰(증분 카운터)과 임대 갱신(renew), DB 제약으로 2차 방어를 함께 사용

### Redlock 적용 설계

<1> 현재 DB 락이 걸려있는 곳:

1. 쿠폰 발급 - 비관적 락
2. 쿠폰 사용, 복구, 취소 - 낙관적 락
3. 포인트 충전, 사용, 복구 - 낙관적 락
4. 재고 예약, 확정, 복구 - 비관적 락

<br/>

<2> 분산락을 실제로 걸어볼 곳:

- 쿠폰 발급
- 재고 예약, 확정, 복구

<br/>

<2-1> 판단기준:

1. 비관적락을 사용하고 있는데 트래픽이 많아질 가능성 높은 경우. 어플리케이션 레이어에서 DB 부담을 덜어주는 역할
   1-1. 해당 경우 이상적으로 비관적락은 fallback으로서 존재.
2. DB 락을 걸어야하는데 영속성 계층에 여러 소스들이 있는 경우 (예 - Mongodb, Postgres 동시 사용)
3. 락의 범위 자체가 어플리케이션 레벨에서 걸려야하는 경우 (예 - 토큰 발급 관련 등)
4. 사실 어느 임계점 부터 redlock이 유효한지는 k6로 측정해보아야만이 정확히 알 수 있다고 생각하여 실제로 측정했습니다.

사실상 위의 판단 기준 중 유효한 것은 1, 4밖에 없기에 기본적으로 비관적 락이 걸린 곳에 분산락 구현을 한 뒤에 k6로 성능 비교를 진행합니다.

<br/>

### Redlock의 한계점 보완

- 펜싱 토큰 구현과 트랜잭션 처리 고도화
