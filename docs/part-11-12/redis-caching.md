# Redis 캐싱 전략

## 1. 결과 요약

| 엔드포인트           | 캐시 상태 | 응답 시간 (p95) | 성능 개선율  |
| -------------------- | --------- | --------------- | ------------ |
| **Popular Products** | 캐시 있음 | 3.13ms          | **57% 개선** |
|                      | 캐시 없음 | 7.25ms          | -            |
| **Product Details**  | 캐시 있음 | 3.72ms          | **60% 개선** |
|                      | 캐시 없음 | 9.3ms           | -            |
| **User Orders**      | 캐시 있음 | 59.09ms         | **4% 하락**  |
|                      | 캐시 없음 | 56.58ms         | -            |

\* `redis-caching-test-log.md`에서 상세한 k6 테스트 기록 확인 가능합니다.

## 2. 분석

- **인기 상품 조회**: 57% 응답 시간 단축 (7.25ms → 3.13ms)
- **상품 상세 조회**: 60% 응답 시간 단축 (9.3ms → 3.72ms)
- **사용자 주문 조회**: 캐싱 있는 것과 없는 것이 비등함. => 이거 시간 부족해서 정확한 원인 분석 못했는데 아마 제 실수가 어디엔가 있지 않을까 싶습니다.

실제 환경이랑은 조금 다른게, 제가 응답 시간 확인을 극대화하기 위해서 k6 테스트에서 for loop으로 여러번씩 조회하도록 했습니다.
그래서 세팅에 따라 %는 많이 요동칠 수 있습니다. 그냥 더 빠른지만 확인했다고 봐주시면 감사할 것 같습니다.

## 3. 추가 고려 가능한 엔드포인트

- `GET /api/users/me/points/balance` - 사용자 잔액 조회
- `GET /api/coupons` - 사용 가능 쿠폰 목록
- `GET /api/coupons/:couponId` - 쿠폰 상세 조회
- `GET /api/products` - 전체 상품 조회 (첫 페이지만)

## 4. TTL 정책

| 캐시 대상            | TTL   | 갱신 주기                         | 무효화 트리거     |
| -------------------- | ----- | --------------------------------- | ----------------- |
| **인기 상품 통계**   | 30분  | 5분마다 백그라운드 갱신           | 주문 완료 시      |
| **사용자 주문 이력** | 10분  | 새 주문 생성 시 즉시 무효화       | 주문 상태 변경 시 |
| **상품 상세 정보**   | 1시간 | 상품 정보 업데이트 시 즉시 무효화 | 상품 수정 시      |

## 5. 돌리는 법

```
npm run seed:cache-test-data
npm run k6:cache:popular-products
npm run k6:cache:popular-products:disabled
cleanup:cache-test-data
```
