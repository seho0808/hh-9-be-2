import { Test, TestingModule } from "@nestjs/testing";
import { DataSource, Repository } from "typeorm";
import { getRepositoryToken } from "@nestjs/typeorm";
import { ConfigService } from "@nestjs/config";
import Redis from "ioredis";
import {
  TestEnvironmentFactory,
  TestEnvironment,
} from "../../../test-environment/test-environment.factory";
import { CouponFactory } from "@/coupon/infrastructure/persistence/factories/coupon.factory";
import { CouponTypeOrmEntity } from "@/coupon/infrastructure/persistence/orm/coupon.typeorm.entity";
import { UserCouponTypeOrmEntity } from "@/coupon/infrastructure/persistence/orm/user-coupon.typeorm.entity";
import { IssueUserCouponWithPubSubLockUseCase } from "@/coupon/application/use-cases/tier-2/issue-user-coupon-with-pubsub-lock.use-case";
import { IssueUserCouponUseCase } from "@/coupon/application/use-cases/tier-1-in-domain/issue-user-coupon.use-case";
import { CouponRepository } from "@/coupon/infrastructure/persistence/coupon.repository";
import { UserCouponRepository } from "@/coupon/infrastructure/persistence/user-coupon.repository";
import { ValidateUserCouponService } from "@/coupon/domain/services/validate-user-coupon.service";
import { RedisManager } from "@/common/infrastructure/config/redis.config";
import { PubSubLockService } from "@/common/infrastructure/locks/pubsub-lock.service";

describe("PubSub Lock Specific Tests", () => {
  let factory: TestEnvironmentFactory;
  let environment: TestEnvironment;
  let dataSource: DataSource;
  let couponRepository: Repository<CouponTypeOrmEntity>;
  let userCouponRepository: Repository<UserCouponTypeOrmEntity>;
  let issueUserCouponWithPubSubLockUseCase: IssueUserCouponWithPubSubLockUseCase;
  let pubSubLockService: PubSubLockService;
  let redisManager: RedisManager;

  beforeAll(async () => {
    factory = new TestEnvironmentFactory();
    environment = await factory.createDatabaseAndRedisEnvironment();
    dataSource = environment.dataSource;

    couponRepository = dataSource.getRepository(CouponTypeOrmEntity);
    userCouponRepository = dataSource.getRepository(UserCouponTypeOrmEntity);

    const mockConfigService = {
      get: jest.fn((key: string, defaultValue?: any) => {
        const config = {
          REDIS_HOST: environment.redisContainer!.getHost(),
          REDIS_PORT: environment.redisContainer!.getPort(),
          REDIS_DB: 0,
        };
        return config[key] || defaultValue;
      }),
    };

    const moduleFixture: TestingModule = await Test.createTestingModule({
      providers: [
        {
          provide: getRepositoryToken(CouponTypeOrmEntity),
          useValue: couponRepository,
        },
        {
          provide: getRepositoryToken(UserCouponTypeOrmEntity),
          useValue: userCouponRepository,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
        CouponRepository,
        UserCouponRepository,
        ValidateUserCouponService,
        IssueUserCouponUseCase,
        RedisManager,
        PubSubLockService,
        IssueUserCouponWithPubSubLockUseCase,
      ],
    }).compile();

    issueUserCouponWithPubSubLockUseCase =
      moduleFixture.get<IssueUserCouponWithPubSubLockUseCase>(
        IssueUserCouponWithPubSubLockUseCase
      );
    pubSubLockService = moduleFixture.get<PubSubLockService>(PubSubLockService);
    redisManager = moduleFixture.get<RedisManager>(RedisManager);
  });

  afterAll(async () => {
    await redisManager.disconnect();
    await factory.cleanup(environment);
  });

  beforeEach(async () => {
    await environment.dbHelper.clearDatabase();
    await environment.dataHelper.createTestUser();

    const hashedPassword = "hashed_password";
    const users = Array.from({ length: 20 }, (_, i) => ({
      id: `user-${i}`,
      email: `user${i}@example.com`,
      password: hashedPassword,
      name: `ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê ${i}`,
      created_at: new Date(),
      updated_at: new Date(),
    }));

    await dataSource
      .createQueryBuilder()
      .insert()
      .into("users")
      .values(users)
      .execute();

    CouponFactory.resetCounter();

    // Redis ÌÅ¥Î¶¨Ïñ¥
    const redis = redisManager.getClient();
    await redis.flushdb();
  });

  describe("PubSub ÏïåÎ¶º Î©îÏª§ÎãàÏ¶ò ÌÖåÏä§Ìä∏", () => {
    it("PubSub LockÏùò ÎèôÏãúÏÑ± Ï†úÏñ¥Í∞Ä Ï†ïÌôïÌûà ÏûëÎèôÌïòÎäîÏßÄ ÌôïÏù∏", async () => {
      // Given: Îã®Ïùº Ïø†Ìè∞ÏúºÎ°ú ÎùΩ Í≤ΩÌï© ÌÖåÏä§Ìä∏
      const coupon = await CouponFactory.createAndSave(couponRepository, {
        couponCode: "PUBSUB_CONCURRENCY_TEST",
        discountValue: 1000,
        discountType: "FIXED",
        totalCount: 1, // Îã® 1Í∞úÎßå Î∞úÍ∏â Í∞ÄÎä•
        issuedCount: 0,
        endDate: new Date(Date.now() + 86400000),
      });

      // When: ÎèôÏãúÏóê Ïó¨Îü¨ ÏöîÏ≤≠ÏúºÎ°ú ÎùΩ Í≤ΩÌï© ÏÉùÏÑ±
      const concurrentRequests = 5;
      const promises = Array.from({ length: concurrentRequests }, (_, i) =>
        issueUserCouponWithPubSubLockUseCase
          .execute({
            couponId: coupon.id,
            userId: `user-${i}`,
            couponCode: "PUBSUB_CONCURRENCY_TEST",
            idempotencyKey: `pubsub-concurrency-${i}`,
          })
          .catch((error) => ({ error, userId: `user-${i}` }))
      );

      const results = await Promise.all(promises);

      // Then: Ï†ïÌôïÌûà 1Í∞úÎßå ÏÑ±Í≥µÌïòÍ≥† ÎÇòÎ®∏ÏßÄÎäî Ïã§Ìå®Ìï¥Ïïº Ìï®
      const successes = results.filter((result) => !("error" in result));
      const failures = results.filter((result) => "error" in result);

      expect(successes.length).toBe(1);
      expect(failures.length).toBe(concurrentRequests - 1);

      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú Í≤ÄÏ¶ù
      const updatedCoupon = await couponRepository.findOne({
        where: { id: coupon.id },
      });
      expect(updatedCoupon.issuedCount).toBe(1);

      console.log(`‚úÖ PubSub Lock ÎèôÏãúÏÑ± Ï†úÏñ¥ Í≤ÄÏ¶ù:`);
      console.log(
        `   - ÏÑ±Í≥µ: ${successes.length}Í∞ú, Ïã§Ìå®: ${failures.length}Í∞ú`
      );
      console.log(`   - Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Ïú†ÏßÄÎê®`);
    });

    it("PubSub + Ìè¥ÎßÅ ÌïòÏù¥Î∏åÎ¶¨Îìú Î©îÏª§ÎãàÏ¶òÏù¥ Ï†ïÏÉÅ ÎèôÏûëÌïòÎäîÏßÄ ÌôïÏù∏", async () => {
      // Given: Ï†úÌïúÎêú ÏàòÎüâÏùò Ïø†Ìè∞ÏúºÎ°ú ÎùΩ Í≤ΩÌï© ÏÉÅÌô© ÏÉùÏÑ±
      const coupon = await CouponFactory.createAndSave(couponRepository, {
        couponCode: "PUBSUB_HYBRID_TEST",
        discountValue: 1000,
        discountType: "FIXED",
        totalCount: 3, // 3Í∞úÎßå Î∞úÍ∏â Í∞ÄÎä•ÌïòÏó¨ Ï†ÅÏ†àÌïú Í≤ΩÌï© Î∞úÏÉù
        issuedCount: 0,
        endDate: new Date(Date.now() + 86400000),
      });

      // When: ÎÜíÏùÄ ÎèôÏãúÏÑ±ÏúºÎ°ú ÏöîÏ≤≠ÌïòÏó¨ PubSub Î©îÏª§ÎãàÏ¶ò ÌÖåÏä§Ìä∏
      const concurrentRequests = 10;
      const startTime = Date.now();

      const promises = Array.from({ length: concurrentRequests }, (_, i) =>
        issueUserCouponWithPubSubLockUseCase
          .execute({
            couponId: coupon.id,
            userId: `user-${i}`,
            couponCode: "PUBSUB_HYBRID_TEST",
            idempotencyKey: `pubsub-hybrid-${i}`,
          })
          .catch((error) => ({ error, userId: `user-${i}` }))
      );

      const results = await Promise.all(promises);
      const totalDuration = Date.now() - startTime;

      // Then: Ï†ïÌôïÌûà 3Í∞úÎßå ÏÑ±Í≥µÌïòÍ≥† ÎÇòÎ®∏ÏßÄÎäî Ïã§Ìå®Ìï¥Ïïº Ìï®
      const successes = results.filter((result) => !("error" in result));
      const failures = results.filter((result) => "error" in result);

      expect(successes.length).toBe(3);
      expect(failures.length).toBe(7);

      // Ïø†Ìè∞ Î∞úÍ∏â ÏàòÎüâ Í≤ÄÏ¶ù
      const updatedCoupon = await couponRepository.findOne({
        where: { id: coupon.id },
      });
      expect(updatedCoupon.issuedCount).toBe(3);

      console.log(`‚úÖ PubSub ÌïòÏù¥Î∏åÎ¶¨Îìú ÎùΩ Í≤ÄÏ¶ù ÏôÑÎ£å:`);
      console.log(
        `   - ÏÑ±Í≥µ: ${successes.length}Í∞ú, Ïã§Ìå®: ${failures.length}Í∞ú`
      );
      console.log(`   - Ï¥ù Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ${totalDuration}ms`);
      console.log(`   - PubSub + Ìè¥ÎßÅ Î©îÏª§ÎãàÏ¶òÏù¥ Ï†ïÏÉÅ ÎèôÏûëÌï®`);
    });
  });

  describe("PubSub Lock ÏÑ±Îä• ÌÖåÏä§Ìä∏", () => {
    it("ÎÜíÏùÄ ÎèôÏãúÏÑ± ÌôòÍ≤ΩÏóêÏÑú PubSub Lock ÏÑ±Îä• Í≤ÄÏ¶ù", async () => {
      // Given: Ï†ÅÎãπÌïú ÏàòÎüâÏùò Ïø†Ìè∞ÏúºÎ°ú ÏÑ±Îä• ÌÖåÏä§Ìä∏
      const coupon = await CouponFactory.createAndSave(couponRepository, {
        couponCode: "PUBSUB_PERFORMANCE_TEST",
        discountValue: 1000,
        discountType: "FIXED",
        totalCount: 5, // 5Í∞ú Î∞úÍ∏â Í∞ÄÎä•
        issuedCount: 0,
        endDate: new Date(Date.now() + 86400000),
      });

      // When: ÎÜíÏùÄ ÎèôÏãúÏÑ±ÏúºÎ°ú ÏöîÏ≤≠ Ïã§Ìñâ
      const concurrentRequests = 15;
      const startTime = Date.now();

      const promises = Array.from({ length: concurrentRequests }, (_, i) =>
        issueUserCouponWithPubSubLockUseCase
          .execute({
            couponId: coupon.id,
            userId: `user-${i}`,
            couponCode: "PUBSUB_PERFORMANCE_TEST",
            idempotencyKey: `pubsub-performance-${i}`,
          })
          .catch((error) => ({ error, userId: `user-${i}` }))
      );

      const results = await Promise.all(promises);
      const totalDuration = Date.now() - startTime;

      // Then: ÏÑ±Îä• Î∞è Ï†ïÌôïÏÑ± Í≤ÄÏ¶ù
      const successes = results.filter((result) => !("error" in result));
      const failures = results.filter((result) => "error" in result);

      expect(successes.length).toBe(5);
      expect(failures.length).toBe(10);

      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
      const updatedCoupon = await couponRepository.findOne({
        where: { id: coupon.id },
      });
      expect(updatedCoupon.issuedCount).toBe(5);

      const throughput = (successes.length / totalDuration) * 1000;

      console.log(`üìä PubSub Lock ÏÑ±Îä• ÌÖåÏä§Ìä∏ Í≤∞Í≥º:`);
      console.log(
        `   - ÏÑ±Í≥µ: ${successes.length}Í∞ú, Ïã§Ìå®: ${failures.length}Í∞ú`
      );
      console.log(`   - Ï¥ù Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ${totalDuration}ms`);
      console.log(`   - Ï≤òÎ¶¨Îüâ: ${throughput.toFixed(2)} requests/sec`);
      console.log(`   - Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ±: ‚úÖ`);

      // ÏÑ±Îä• Í∏∞Ï§Ä: 15Í∞ú ÏöîÏ≤≠ÏùÑ 3Ï¥à ÎÇ¥Ïóê Ï≤òÎ¶¨Ìï¥Ïïº Ìï®
      expect(totalDuration).toBeLessThan(3000);
    });
  });

  describe("PubSub Lock ÏïàÏ†ïÏÑ± ÌÖåÏä§Ìä∏", () => {
    it("PubSub LockÏù¥ ÏïàÏ†ïÏ†ÅÏúºÎ°ú ÎèôÏûëÌïòÎäîÏßÄ Í≤ÄÏ¶ù", async () => {
      // Given: Ïó¨Îü¨ Ïø†Ìè∞ Î∞úÍ∏â Í∞ÄÎä•Ìïú ÏÉÅÌô©
      const coupon = await CouponFactory.createAndSave(couponRepository, {
        couponCode: "PUBSUB_STABILITY_TEST",
        discountValue: 1000,
        discountType: "FIXED",
        totalCount: 3, // 3Í∞ú Î∞úÍ∏â Í∞ÄÎä•
        issuedCount: 0,
        endDate: new Date(Date.now() + 86400000),
      });

      // When: Ï†ïÌôïÌûà Ïø†Ìè∞ ÏàòÎüâÎßåÌÅº ÏöîÏ≤≠
      const promises = Array.from({ length: 3 }, (_, i) =>
        issueUserCouponWithPubSubLockUseCase
          .execute({
            couponId: coupon.id,
            userId: `user-${i}`,
            couponCode: "PUBSUB_STABILITY_TEST",
            idempotencyKey: `pubsub-stability-${i}`,
          })
          .catch((error) => ({ error, userId: `user-${i}` }))
      );

      const results = await Promise.all(promises);

      // Then: Î™®Îì† ÏöîÏ≤≠Ïù¥ ÏÑ±Í≥µÌï¥Ïïº Ìï® (Í≤ΩÌï© ÏóÜÎäî ÏÉÅÌô©)
      const successes = results.filter((result) => !("error" in result));
      const failures = results.filter((result) => "error" in result);

      expect(successes.length).toBe(3);
      expect(failures.length).toBe(0);

      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
      const updatedCoupon = await couponRepository.findOne({
        where: { id: coupon.id },
      });
      expect(updatedCoupon.issuedCount).toBe(3);

      console.log(`‚úÖ PubSub Lock ÏïàÏ†ïÏÑ± Í≤ÄÏ¶ù ÏôÑÎ£å:`);
      console.log(`   - Î™®Îì† ÏöîÏ≤≠ ÏÑ±Í≥µ: ${successes.length}Í∞ú`);
      console.log(`   - ÌïòÏù¥Î∏åÎ¶¨Îìú Î©îÏª§ÎãàÏ¶ò ÏïàÏ†ïÏ†Å ÎèôÏûë ÌôïÏù∏`);
    });
  });
});
